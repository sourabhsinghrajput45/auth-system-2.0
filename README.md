# Auth System 2.0

A production-grade authentication system built with **Quarkus (Backend)** and **Vite + React (Frontend)**.  
This project focuses on correctness, security, and operational clarity rather than over-engineering.

---

## Table of Contents

1. Overview  
2. Architecture  
3. Technology Stack  
4. Authentication Model  
5. Backend API Design  
6. Frontend Design  
7. Security Considerations  
8. Environment Configuration  
9. Local Development  
10. Deployment  
11. Known Constraints and Design Choices  

---

## 1. Overview

Auth System 2.0 is a cookie-based authentication platform designed for real-world deployment.  
It implements:

- Secure HTTP-only cookies
- Email verification
- Stateless access tokens
- Clear separation of frontend and backend responsibilities

The system intentionally avoids client-side token storage and keeps all authentication decisions on the backend.

---

## 2. Architecture

High-level architecture:

→ Frontend (Vite + React)  
→ HTTPS requests with credentials  
→ Backend (Quarkus REST API)  
→ PostgreSQL database  

Key principles:
- Backend is the single source of truth
- Frontend never parses or stores tokens
- Authentication is enforced by backend request filters

---

## 3. Technology Stack

### Backend
- Quarkus 3.x
- JAX-RS (RESTEasy)
- Hibernate ORM with Panache
- PostgreSQL
- Jakarta CDI
- HTTP-only cookie authentication

### Frontend
- Vite
- React
- Tailwind CSS
- Fetch API with `credentials: "include"`

### Deployment
- Backend hosted on Render
- Frontend hosted on Vercel

---

## 4. Authentication Model

### Token Strategy
- Access tokens are generated by the backend
- Tokens are stored in Secure, HTTP-only cookies
- Cookies use `SameSite=None` for cross-site frontend/backend hosting
- Tokens are never exposed to JavaScript

### Email Verification
- Email verification is supported but does not block login
- Verification status is returned by backend APIs
- Frontend displays verification status without enforcing routing logic

---

## 5. Backend API Design

### Public Endpoints

| Method | Path           | Description |
|------|---------------|-------------|
| POST | /auth/signup   | Register new user |
| GET  | /auth/verify   | Verify email token |
| POST | /auth/login    | Authenticate user |
| GET  | /auth/status   | Get authentication and verification status |
| POST | /auth/logout   | Expire authentication cookie |

### Protected Endpoints

| Method | Path | Description |
|------|------|-------------|
| GET  | /me  | Returns authenticated user information |

### Request Filtering
- All protected routes are enforced by an authentication filter
- Filter validates cookie-based access tokens
- Authenticated user is attached to the request security context

---

## 6. Frontend Design

### State Management
- Global authentication state managed via `AuthContext`
- Backend responses are treated as authoritative
- No assumptions are made from previous frontend state

### Routing
- Login and signup are public
- Dashboard is accessible after login
- Email verification is displayed as informational UI only

### Logout Behavior
- Frontend clears its state
- Backend expires the authentication cookie
- No token parsing or storage occurs in the frontend

---

## 7. Security Considerations

- No tokens in localStorage or sessionStorage
- Cookies are HTTP-only and Secure
- Cross-site requests require explicit CORS configuration
- Backend validates every request independently
- Frontend cannot impersonate authentication state

---

## 8. Environment Configuration

### Backend
Required environment variables:
- DATABASE_URL
- DATABASE_USERNAME
- DATABASE_PASSWORD
- MAIL_HOST
- MAIL_USERNAME
- MAIL_PASSWORD

### Frontend
Required environment variables:
- VITE_API_BASE_URL

---

## 9. Local Development

### Backend
1. Configure PostgreSQL
2. Set environment variables
3. Run:
   ```
   ./mvnw quarkus:dev
   ```

### Frontend
1. Install dependencies:
   ```
   npm install
   ```
2. Start development server:
   ```
   npm run dev
   ```

---

## 10. Deployment

### Backend (Render)
- Containerized Quarkus application
- HTTPS enforced
- Port binding configured for Render environment

### Frontend (Vercel)
- Static build via Vite
- Environment variables injected at build time
- Communicates with backend using HTTPS and cookies

---

## 11. Known Constraints and Design Choices

- Email verification status updates require re-login (by design)
- Stateless access tokens are not refreshed automatically
- Logout is cookie-based rather than token-revocation-based
- Simplicity and reliability are prioritized over advanced flows

---

This makes the system easier to debug, reason about, and maintain in real deployments.
